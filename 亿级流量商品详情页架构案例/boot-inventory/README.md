## 如何中实现缓存与数据库双写一致性保障方案
- 更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个jvm内部的队列中
- 读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个jvm内部的队列中
- 一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行
- 这样的话，一个数据变更的操作，先执行，删除缓存，然后再去更新数据库，但是还没完成更新
- 此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成
- 这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可
- 待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中
- 如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回;
- 如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值

```
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);

(queueNum - 1) & hash
```
