## 分布式事物
- 分布式事务是指事务的参与者，支持事务的服务器，资源服务器分别位于分布式系统的不同节点之上，通常一个分布式事物中会涉及到对多个数据源或业务系统的操作。
- 典型的分布式事务场景：跨银行转操作就涉及调用两个异地银行服务

### CAP理论
-  CAP理论：一个分布式系统不可能同时满足一致性，可用性和分区容错性这个三个基本需求，最多只能同时满足其中两项
- 一致性(C)：数据在多个副本之间是否能够保持一致的特性。
- 可用性(A)：是指系统提供的服务必须一致处于可用状态，对于每一个用户的请求总是在有限的时间内返回结果，超过时间就认为系统是不可用的
- 分区容错性(P)：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生故障。

### CAP定理的应用
- 放弃P(CA)：如果希望能够避免系统出现分区容错性问题，一种较为简单的做法就是将所有的数据(或者是与事物先相关的数据)都放在一个分布式节点上，这样索然无法保证100%系统不会出错，但至少不会碰到由于网络分区带来的负面影响
- 放弃A(CP):其做法是一旦系统遇到网络分区或其他故障时，那马受到影响的服务需要等待一定的时间，英雌等待期间系统无法对外提供正常的服务，即不可用
- 放弃C(AP):这里说的放弃一致性，并不是完全不需要数据一致性，是指放弃数据的强一致性，保留数据的最终一致性。


### BASE理论
- BASE是基本可用，软状态，最终一致性。是对CAP中一致性和可用性权限的结果，是基于CAP定理演化而来的，核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特定，采用适当的方式来使系统达到最终一致性

### 2PC提交
- 二阶段提交协议是将食物的提交过程分成提交事务请求和执行事务提交两个阶段进行处理。

#### 阶段1：提交事物请求
- 事务询问：协调者向所有的参与者发送事物内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应
- 执行事务：各参与者节点执行事物操作，并将Undo和Redo信息记入事务日志中
- 如果参与者成功执事务操作，就反馈给协调者Yes响应，表示事物可以执行，如果没有成功执行事务，就反馈给协调者No响应，表示事务不可以执行
- 二阶段提交一些的阶段一夜被称为投票阶段，即各参与者投票票表明是否可以继续执行接下去的事物提交操作

#### 阶段二：执行事物提交
- 假如协调者从所有的参与者或得反馈都是Yes响应，那马就会执行事务提交。
- 发送提交请求：协调者向所有参与者节点发出Commit请求
- 事务提交：参与者接受到Commit请求后，会正式执行事物提交操作，并在完成提交之后放弃整个事务执行期间占用的事务资源
- 反馈事务提交结果:参与者在完成事物提交之后，向协调者发送ACK消息
- 完成事务：协调者接收到所有参与者反馈的ACK消息后，完成事物

#### 中断事务
- 假如任何一个参与者向协调者反馈了No响应，或者在等待超市之后，协调者尚无法接收到所有参与者的反馈响应，那么就中断事物。
- 发送回滚请求：协调者向搜优参与者节点发出Rollback请求
- 事物回滚：参与者接收到Rollback请求后，会利用其在阶段一种记录的Undo信息执行事物回滚操作，并在完成回滚之后释放事务执行期间占用的资源。
- 反馈事务回滚结果：参与则在完成事务回滚之后，向协调者发送ACK消息
- 中断事务：协调者接收到所有参与者反馈的ACk消息后，完成事务中断、

> 优缺点

- 原理简单，实现方便
- 缺点是同步阻塞，单点问题，脑裂，保守

### 3PC提交
- 三阶段提，也叫三阶段提交协议，是二阶段提交（2PC）的改进版本。
- 与两阶段提交不同的是，三阶段提交有两个改动点。引入超时机制。同时在协调者和参与者中都引入超时机制。在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
- 阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。


## Seata分布式事务方案
- Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。


### Seata术语
- TC：事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。
- TM：事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务
- RM：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。

### Seata的2PC方案
- 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
- 二阶段：提交异步化，非常快速地完成。回滚通过一阶段的回滚日志进行反向补偿。
- 一阶段本地事务提交前，需要确保先拿到 全局锁 。拿不到 全局锁 ，不能提交本地事务。
- 拿全局锁的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。
- 在数据库本地事务隔离级别读已提交或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 读未提交 
- 如果应用在特定场景下，必需要求全局的 读已提交 ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。


### Seata执行流程分析

![seatas执行流程.png](http://ww1.sinaimg.cn/large/0068QeGHgy1g9acjgu9lgj30km0f80uh.jpg)

- 每个`RM`使用`DataSourceProxy`链接数据路，目的是使用`ConnectionProxy`,使用数据源和数据代理的目的是在第一阶段将`undo_log`和业务数据放在一个本地事务提交，这样就保存了只要有业务操作就一定有undo_log
- 在第一阶段undo_log中存放了数据修改前后修改后的值，为事务回滚做好准别，所以第一阶段完成就已经将分支事务提交了，也就释放了锁资源
-  TM开启全局事务开始，将XID全局事务ID放在事务上下文中，通过feign调用也将XID传入下游分支事务，每个分支事务将自己的Branch ID 分支事务ID与XID关联
-  第二阶段全局事务提交，TC会通知各分支参与者提交分支事务，在第一阶段就已经提交了分支事务，这里各参与者只需要参数undo_log即可，并且可以异步执行，第二阶段很快可以完成
-  如果某一个分支事务异常，第二阶段就全局事务回滚操作，TC会通知各分支参与者回滚分支事务，通过`XID`和`Branch-ID`找到对应的回滚日志，通过回滚日志生成的反向`SQL`并执行，以完成分支事务回滚到之前

### Seata的实战案列
- https://github.com/seata/seata-samples
- https://github.com/seata/seata-samples/blob/master/doc/quick-integration-with-spring-cloud.md
- 第一步：下载官方SpringCloud案列
- 第二步：从 https://github.com/seata/seata/releases,下载服务器软件包，注意修改registry.conf配置文件的注册中心类型


> https://start.spring.io/actuator/info